<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DJ Track Analyzer</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: Arial, sans-serif; margin: 32px; background: #111; color: #eee; }
    h1 { color: #00ff88; margin-bottom: 10px; }
    .row { display: flex; gap: 10px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
    input[type=file], button { padding: 8px; }
    #report { margin-top: 16px; padding: 18px; border: 1px solid #2a2a2a; border-radius: 8px; background: #1b1b1b; }
    .label { color: #aaa; }
    .value { color: #fff; }
    .notes li { margin-bottom: 6px; }
    .ok { color: #00d084; }
    .warn { color: #ffb44d; }
    .bad { color: #ff6a6a; }

    /* Waveform */
    .wave-wrap { margin-top: 18px; border: 1px solid #2a2a2a; border-radius: 8px; background:#0f0f0f; position: relative; }
    #wave { width: 100%; height: 160px; display: block; }
    .wave-meta { display:flex; justify-content: space-between; font-size: 12px; color:#aaa; padding:6px 10px; }

    /* Small badge */
    #breakBadge {
      display:inline-block; padding:6px 10px; border-radius:8px;
      background:#6b7280; color:#fff; font-weight:600; margin-left:8px;
    }
  </style>
</head>
<body>
  <h1>DJ Track Analyzer</h1>

  <div class="row">
    <input type="file" id="file" accept=".wav,.mp3,.aiff,.flac" />
    <button id="btn">Analyze</button>
    <span id="status" class="label"></span>
    <span id="breakBadge">Waiting for analysis…</span>
  </div>

  <!-- Waveform -->
  <div class="wave-wrap">
    <canvas id="wave"></canvas>
    <div class="wave-meta">
      <span id="wave-left">0:00</span>
      <span id="wave-right">0:00</span>
    </div>
  </div>

  <div id="report"></div>

  <script>
    const fileInput = document.getElementById("file");
    const canvas = document.getElementById("wave");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const leftTime = document.getElementById("wave-left");
    const rightTime = document.getElementById("wave-right");
    const report = document.getElementById("report");

    // Badge + colors
    const breakBadge = document.getElementById("breakBadge");
    const bbColors = { green:'#16a34a', red:'#dc2626', orange:'#f59e0b', unknown:'#6b7280' };

    // Current audio buffer
    let lastPCM = null, lastSR = 44100, lastDuration = 0;
    // Server highlight
    let highlight = null;

    // helper: format time
    function formatTime(sec) { const m = Math.floor(sec/60), s = Math.round(sec%60); return `${m}:${s.toString().padStart(2,"0")}`; }

    // Fit canvas to CSS pixels, draw in CSS units
    function fitCanvasToCSS() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      const cssW = Math.floor(rect.width);
      const cssH = Math.floor(rect.height);

      canvas.width  = cssW * dpr;
      canvas.height = cssH * dpr;

      // Make 1 unit == 1 CSS pixel
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      return { dpr, cssW, cssH };
    }

    window.addEventListener("resize", () => { if (lastPCM) drawWave(lastPCM, lastSR, lastDuration, highlight); });

    function drawWave(pcm, sr, durationSec, hl) {
      const { cssW: W, cssH: H } = fitCanvasToCSS(); // draw in CSS pixels

      // background
      ctx.fillStyle = "#0f0f0f";
      ctx.fillRect(0, 0, W, H);

      // center line
      ctx.strokeStyle = "#444";
      ctx.beginPath();
      ctx.moveTo(0, H/2);
      ctx.lineTo(W, H/2);
      ctx.stroke();

      // overlays
      if (hl && durationSec > 0) {
        const { intro_end_sec, outro_start_sec, break_time_sec, tempo_bpm } = hl;

        // If break & tempo are known: green until (break - 64 beats), then white window
        if (break_time_sec != null && tempo_bpm && tempo_bpm > 0) {
          const spb = 60 / tempo_bpm;
          const whiteStartSec = Math.max(0, break_time_sec - 64 * spb);
          const xWhiteStart = (whiteStartSec / durationSec) * W;
          const xBreak      = (break_time_sec / durationSec) * W;

          // Brighter green from start → (break - 64 beats)
          if (!isNaN(xWhiteStart) && xWhiteStart > 0) {
            ctx.fillStyle = "rgba(0,255,136,0.45)"; // brighter green
            ctx.fillRect(0, 0, Math.min(xWhiteStart, W), H);
          }

          // White for the last 64 beats before the break
          if (!isNaN(xBreak) && xBreak > (xWhiteStart || 0)) {
            ctx.fillStyle = "rgba(255,255,255,0.25)";
            ctx.fillRect(Math.max(0, xWhiteStart), 0, Math.min(W, xBreak) - Math.max(0, xWhiteStart), H);
          }

          // Optional: keep outro shading
          if (typeof outro_start_sec === "number") {
            const outroX1 = (outro_start_sec / durationSec) * W;
            if (!isNaN(outroX1) && outroX1 < W) {
              const v = hl.outro_verdict || "warn";
              const col = v === "good" ? "rgba(0,208,132,0.25)"
                        : v === "bad"  ? "rgba(255,80,80,0.30)"
                        :                 "rgba(255,180,77,0.25)";
              ctx.fillStyle = col;
              ctx.fillRect(outroX1, 0, W - outroX1, H);
            }
          }
        } else {
          // Fallback if break/tempo unknown: original intro/outro shading
          const introX2 = (intro_end_sec / durationSec) * W;
          const outroX1 = (outro_start_sec / durationSec) * W;
          const colorFor = v => v === "good" ? "rgba(0,208,132,0.25)"
                          : v === "bad"  ? "rgba(255,80,80,0.30)"
                          :                "rgba(255,180,77,0.25)";
          if (!isNaN(introX2) && introX2 > 0) {
            ctx.fillStyle = colorFor(hl.intro_verdict || "warn");
            ctx.fillRect(0, 0, introX2, H);
          }
          if (!isNaN(outroX1) && outroX1 < W) {
            ctx.fillStyle = colorFor(hl.outro_verdict || "warn");
            ctx.fillRect(outroX1, 0, W - outroX1, H);
          }
        }

        // Break marker
        if (break_time_sec != null) {
          const x = (break_time_sec / durationSec) * W;
          const col = bbColors[hl.beats_to_break_status || "unknown"] || bbColors.unknown;
          ctx.save();
          ctx.strokeStyle = col;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
          ctx.restore();

          ctx.fillStyle = col;
          ctx.font = '12px sans-serif';
          ctx.fillText('Break', x + 4, 14);
        }
      }

      // waveform lines (off-white)
      const columns = Math.min(2000, Math.max(400, Math.floor(W)));
      const blockSize = Math.max(1, Math.floor(pcm.length / columns));
      const halfH = (H * 0.9) / 2;

      ctx.strokeStyle = "#f5f5f5";
      ctx.lineWidth = 1;

      for (let i = 0; i < columns; i++) {
        const start = i * blockSize;
        const end = Math.min(pcm.length, start + blockSize);
        let min = 1.0, max = -1.0;
        for (let j = start; j < end; j++) {
          const v = pcm[j];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        const x = (i / columns) * W;
        const y1 = H/2 - max * halfH;
        const y2 = H/2 - min * halfH;
        ctx.beginPath();
        ctx.moveTo(x, y1);
        ctx.lineTo(x, y2);
        ctx.stroke();
      }

      leftTime.textContent = "0:00";
      rightTime.textContent = formatTime(durationSec);
    }

    async function decodeAndDraw(file) {
      statusEl.textContent = "Loading waveform…";
      try {
        const arrayBuf = await file.arrayBuffer();
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const ac = new AudioCtx();
        const audioBuf = await ac.decodeAudioData(arrayBuf);
        const ch0 = audioBuf.getChannelData(0);
        const ch1 = audioBuf.numberOfChannels > 1 ? audioBuf.getChannelData(1) : null;
        const mono = new Float32Array(audioBuf.length);
        if (ch1) { for (let i=0; i<audioBuf.length; i++) mono[i]=(ch0[i]+ch1[i])*0.5; } else { mono.set(ch0); }
        lastPCM = mono; lastSR = audioBuf.sampleRate; lastDuration = audioBuf.duration;
        drawWave(lastPCM, lastSR, lastDuration, highlight);
        statusEl.textContent = "";
        if (ac.close) ac.close();
      } catch(e) {
        console.error(e);
        statusEl.textContent = "Waveform preview failed.";
      }
    }

    fileInput.addEventListener("change", () => {
      if (fileInput.files && fileInput.files[0]) decodeAndDraw(fileInput.files[0]);
    });

    // Analyze button -> backend call (with timeout, disable button, clear status in all paths)
    const btn = document.getElementById("btn");
    btn.onclick = async () => {
      const f = fileInput.files[0];
      if (!f) { alert("Please select a file."); return; }

      btn.disabled = true;              // NEW: prevent double-clicks
      statusEl.textContent = "Analyzing…";
      report.innerHTML = "Analyzing…";
      const fd = new FormData(); fd.append("file", f);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort("Request timed out"), 90000); // NEW: 90s

      try {
        const res = await fetch("/analyze", { method: "POST", body: fd, signal: controller.signal });
        clearTimeout(timeoutId);

        if (!res.ok) {
          const bodyText = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${res.statusText}${bodyText ? " — " + bodyText : ""}`);
        }

        const data = await res.json();
        if (data.error) throw new Error(data.error);

        // store highlight info for redraw
        highlight = {
          intro_end_sec: data.intro_end_sec,
          outro_start_sec: data.outro_start_sec,
          intro_verdict: data.intro_verdict,
          outro_verdict: data.outro_verdict,
          break_time_sec: data.break_time_sec,
          beats_to_break_status: data.beats_to_break_status,
          tempo_bpm: data.tempo_bpm
        };

        // redraw waveform with overlays + break marker
        if (lastPCM) drawWave(lastPCM, lastSR, lastDuration, highlight);

        // update badge
        updateBreakBadge(data);

        const mins = Math.floor(data.duration_sec / 60);
        const secs = Math.round(data.duration_sec % 60);
        const notes = (data.notes && data.notes.length)
          ? `<ul class="notes">${data.notes.map(n => `<li class="bad">${n}</li>`).join("")}</ul>`
          : `<p class="ok">✅ No major DJ issues detected.</p>`;

        const verdictLabel = v => v==="good" ? '<span class="ok">good</span>' : v==="bad" ? '<span class="bad">bad</span>' : v==="warn" ? '<span class="warn">warning</span>' : '<span class="label">unknown</span>';

        const statusDot = (s) => {
          const col = bbColors[s || 'unknown'] || bbColors.unknown;
          return `<span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${col};margin-right:6px;vertical-align:middle;"></span>`;
        };

        report.innerHTML = `
          <div>
            <p><span class="label">File:</span> <span class="value">${data.file}</span></p>
            <p><span class="label">Length:</span> <span class="value">${mins} min ${secs} sec</span></p>
            <p><span class="label">Tempo:</span> <span class="value">${data.tempo_bpm} BPM</span>
               <span class="label">(confidence:</span> <span class="value">${data.tempo_confidence}%</span><span class="label">)</span></p>
            <p><span class="label">Loudness:</span> <span class="value">${data.loudness_lufs} LUFS</span></p>
            <p><span class="label">Peak:</span> <span class="value">${data.peak_dbfs} dBFS</span></p>

            <p><span class="label">Intro length:</span>
              <span class="value">
                ${(data.intro_beats != null && data.intro_bars != null)
                  ? `${data.intro_beats} beats (${data.intro_bars} bars)`
                  : (data.intro_length ?? "?")}
              </span>
              <span class="label">→</span> ${verdictLabel(data.intro_verdict)}
            </p>

            <p><span class="label">Outro length:</span>
              <span class="value">
                ${(data.outro_beats != null && data.outro_bars != null)
                  ? `${data.outro_beats} beats (${data.outro_bars} bars)`
                  : (data.outro_length ?? "?")}
              </span>
              <span class="label">→</span> ${verdictLabel(data.outro_verdict)}
            </p>

            <p><span class="label">Beats before first break:</span>
              ${statusDot(data.beats_to_break_status)}
              <span class="value">
                ${data.beats_before_break == null
                  ? "not detected"
                  : `${data.beats_before_break} beats (target ${data.target_beats_to_break ?? 192}) — at ${data.break_time_sec != null ? formatTime(data.break_time_sec) : "?"}`}
              </span>
            </p>

            <p><span class="label">Target (from examples):</span>
               <span class="value">intro ${data.target_intro_bars ?? "?"} bars, outro ${data.target_outro_bars ?? "?"} bars</span>
               <span class="label">(${data.examples_count} example${data.examples_count===1?"":"s"})</span></p>

            <p><span class="label">Notes:</span></p>
            ${notes}
          </div>
        `;

      } catch (err) {
        console.error(err);
        if (String(err).includes("AbortError")) {
          report.innerHTML = `<span class="bad"><b>Error:</b> Analysis took too long (90s). Try a WAV, or shorten the file.</span>`;
        } else {
          report.innerHTML = `<span class="bad"><b>Error:</b> ${String(err)}</span>`;
        }
      } finally {
        clearTimeout(timeoutId);
        statusEl.textContent = "";   // always clear status
        btn.disabled = false;        // re-enable button
      }
    };

    // Badge updater
    function updateBreakBadge(data){
      const beats  = data.beats_before_break;            // int or null
      const target = data.target_beats_to_break || 192;  // backend sends 192
      const status = data.beats_to_break_status || 'unknown';
      const color  = bbColors[status] || bbColors.unknown;

      if (beats == null){
        breakBadge.textContent = 'Break not detected';
        breakBadge.style.background = bbColors.unknown;
      } else {
        breakBadge.textContent = `${beats} beats → target ${target}`;
        breakBadge.style.background = color;
      }
    }

    // initial canvas setup
    function init() { fitCanvasToCSS(); }
    init();
  </script>
</body>
</html>